#include "Constants.h"

extern "C"{

    #define K1 607.760009765625f
    #define UR 36.459999084472656f
    #define K2 1260.56005859375f
    #define Kt 1.0f
    #define reflectanciaAtmosfera 0.029999999329447746f
    #define StefanBoltzman 5.669999936230852E-8f
    #define L 0.10000000149011612f
    #define julianDay 248.0f
    #define Uref 0.9207136034965515f
    #define Ta 32.7400016784668f
    #define P 99.30000305175781f
    #define Rg_24h 243.9499969482422f
    #define S 1367.0f
    #define latitude -16.559999465942383f
    #define Z 50.2400016784668f

    double dr =1.0f+0.033f*cosf(julianDay*2.0f*pi/365.0f);
    double cosZ =cosf(((90.0f-Z)*pi)/180.0f);
    double declinacaoSolar =(pi/180.0f)*(23.45f*sinf((pi/180.0f)*(360.0f*(julianDay-80.0f)/365.0f)));
    double anguloHorarioNascerSol =acosf(-tanf(pi*latitude/180.0f)*tanf(declinacaoSolar));
    double rad_solar_toa =24.0f*60.0f*0.082f*dr*(anguloHorarioNascerSol*sinf(pi*latitude/180.0f)*sinf(declinacaoSolar)+cosf(pi*latitude/180.0f)*cosf(declinacaoSolar)*sinf(anguloHorarioNascerSol))/pi;
    double Rg_24h_mj =0.0864f*Rg_24h;
    double transmissividade24h =Rg_24h_mj/rad_solar_toa;
    double ea =(0.61078f*expf(17.269f*Ta/(237.3f+Ta)))*UR/100.0f;
    double W =0.14f*ea*P+2.1f;
    double transmissividade =0.35f+0.627f*expf((-0.00146f*P/(Kt*cosZ))-0.075f*powf((W/cosZ),0.4f));
    double emissivityAtm =0.625f*powf((1000.0f*ea/(Ta+T0)),0.131f);
    double SWd =(S*cosZ*cosZ)/(1.085f*cosZ+10.0f*ea*(2.7f+cosZ)*0.001f+0.2f);
    double LWdAtm =emissivityAtm*StefanBoltzman*(powf(Ta+T0,4.0f));

    __constant__ double parameterAlbedo[] = {0.2930000126361847f,0.27399998903274536f,0.2329999953508377f,0.15700000524520874f,0.032999999821186066f,0.0f,0.010999999940395355f};



    __device__ void execute_sub(
        double pixel2,
        double pixel3,
        double pixel4,
        double pixel5,
        double pixel1,
        double pixel7,
        double pixel6,

        double * albedo,
        double * NDVI,
        double * SAVI,
        double * IAF,
        double * emissividadeNB,
        double * emissivity,
        double * Ts,
        double * LWd,
        double * Rn
    ){
        double sumBandas = 0;
        double banda1=1;
        double banda2=1;
        double banda3=1;
        double banda4=1;
        double banda5=1;
        double banda6=1;
        double banda7=1;
        double bandaRefletida1=(pi*banda1)/(calibration[0][2]*cosZ*dr);
        sumBandas += parameterAlbedo[0]*bandaRefletida1;
        double bandaRefletida2=(pi*banda2)/(calibration[1][2]*cosZ*dr);
        sumBandas += parameterAlbedo[1]*bandaRefletida2;
        double bandaRefletida3=(pi*banda3)/(calibration[2][2]*cosZ*dr);
        sumBandas += parameterAlbedo[2]*bandaRefletida3;
        double bandaRefletida4=(pi*banda4)/(calibration[3][2]*cosZ*dr);
        sumBandas += parameterAlbedo[3]*bandaRefletida4;
        double bandaRefletida5=(pi*banda5)/(calibration[4][2]*cosZ*dr);
        sumBandas += parameterAlbedo[4]*bandaRefletida5;
        double bandaRefletida6=(pi*banda6)/(calibration[5][2]*cosZ*dr);
        sumBandas += parameterAlbedo[5]*bandaRefletida6;
        double bandaRefletida7=(pi*banda7)/(calibration[6][2]*cosZ*dr);
        sumBandas += parameterAlbedo[6]*bandaRefletida7;
        *albedo = (sumBandas-reflectanciaAtmosfera)/(transmissividade*transmissividade);
        *NDVI = (bandaRefletida4-bandaRefletida3)/(bandaRefletida4+bandaRefletida3);
        *SAVI = ((1.0f+L)*(bandaRefletida4-bandaRefletida3))/(L+bandaRefletida4+bandaRefletida3);
        *IAF = (-logf((0.69f- *SAVI)/0.59f)/0.91f);
        *emissividadeNB = 0.97f+0.0033f* *IAF;
        *emissivity = 0.95f+0.01f* *IAF;
        *Ts = K2/logf((( *emissividadeNB*K1)/banda6)+1.0f);
        *LWd =  *emissivity*StefanBoltzman*(powf( *Ts,4.0f));
        *Rn = ((1.0f- *albedo)*SWd)+( *emissivity*(LWdAtm)- *LWd);
    }

    __global__ void execute(
        double * pixel2,
        double * pixel3,
        double * pixel4,
        double * pixel5,
        double * pixel1,
        double * pixel7,
        double * pixel6,

        double * albedo,
        double * NDVI,
        double * SAVI,
        double * IAF,
        double * emissividadeNB,
        double * emissivity,
        double * Ts,
        double * LWd,
        double * Rn,
        int size){
        int idx = blockIdx.x*blockDim.x + threadIdx.x;
        if(idx < size){
            execute_sub(
                pixel2[idx],
                pixel3[idx],
                pixel4[idx],
                pixel5[idx],
                pixel1[idx],
                pixel7[idx],
                pixel6[idx],
                (albedo+idx),
                (NDVI+idx),
                (SAVI+idx),
                (IAF+idx),
                (emissividadeNB+idx),
                (emissivity+idx),
                (Ts+idx),
                (LWd+idx),
                (Rn+idx)
            );
        }
    }
}

